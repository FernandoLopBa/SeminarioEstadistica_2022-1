# -*- coding: utf-8 -*-
"""Tarea 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HhcBxTROobfWiMf16vFLjk5AOQUvSJQ8
"""

# Ejercicio 3
# Importamos las librerías necesarias para calcular el modelo de regresión lineal 
import pandas as pd
import numpy as np
# Exportamos la base correspondiente a las 3 empresas; el monto de sustancia que sobra dependiendo el número de horas que se estuvo usando el aparato A,B,C 
bd="/content/lineal_horm.xlsx"
bd_horm=pd.read_excel(bd)
# Inspección rápida de la base 
bd_horm.head()

# Librería para ajsutar una proyección lineal
from sklearn import linear_model
reg = linear_model.LinearRegression()

a= bd_horm[0:9]
b= bd_horm[9:18]
c= bd_horm[18:27]

#Empresa A
a1=a[["horas"]]
a1

# Empresa A
#Separamos la variable objetivo (y=monto) y la variable que nos ayudará a crear la regresión lineal (x=horas)
a1 = a[["horas"]] 
y_a = a[["monto"]]

#Función que recibe la información con la cual entrenaré al modelo
reg.fit(a1, y_a) 
reg.coef_ 
reg.intercept_
#Deuelve valores que se generaron con el modelo lineal tomando en cuenta la variable 'horas'
Y_a_pred = reg.predict(a1)
y_estim_a= Y_a_pred.reshape(-1)
y_estim_a

x_a=a1.to_numpy().reshape(-1)
x_a

# Datos reales
y_real_a=y_a.to_numpy()
y_real_a=y_real_a.reshape(-1)
y_real_a
n=len(y_real_a)
y_real_a

#Diferencia entre la estimación que se obtuvo con el modelo de regresión lineal y los datos reales 
residual_a=y_real_a-y_estim_a
residual_a

# Obtener el error estándar del estimador beta usando:

"""$$
\begin{equation}
\hat{se}_{\beta}=\sqrt{\frac{\sum_{i} \epsilon_{i}^{2}}{(n-2)\sum_{i}(x-\bar{x})^{2}}}
\end{equation}
$$
"""

A1=a1.to_numpy().reshape(-1)
A1

A1=a1.to_numpy().reshape(-1)
A1

df=pd.DataFrame(y_A,
                columns=['monto'])
df['horas']=A1
df

from sklearn import linear_model

# Hago 1000 simulaciones para calcular el error estándar con el método de Bootstap
simul=1000

beta1_boost=np.array([])
beta0_boost=np.array([])

for i in range(0,simul):
  horas_i=np.random.choice(A1, len(A1), replace=True)
  df_aux=pd.DataFrame(horas_i, columns=['horas'])
  df_aux=pd.merge(df_aux,df,how="inner", on=['horas'])
  df_aux
  X=df_aux[["horas"]]
  y=df_aux[["monto"]]
  reg_i=linear_model.LinearRegression() 
  reg_i.fit(X,y)
  beta1_boost=np.append(beta1_boost,reg_i.coef_)
  beta0_boost=np.append(beta0_boost,reg_i.intercept_)

betas=pd.DataFrame(beta1_boost,
                columns=['beta_1'])
betas['beta_0']=beta0_boost
betas

b1 = b[["horas"]]
y_b = b[["monto"]]
reg.fit(b1, y_b)
reg.coef_
reg.intercept_

df_B=pd.DataFrame(y_b,
                columns=['monto'])
df_B['horas']=b1
df_B

# Empresa B
Y_b_pred = reg.predict(b1) #pronósticamos el monto que queda de cada vitamina con respecto al tiempo de horas que se uso el instrumento fabricado por la empresa B
y_estim_b= Y_b_pred.reshape(-1) 
y_estim_b

x_b=b1.to_numpy().reshape(-1)
x_b

# Valores reales con respecto al monto de sustancia que sobró usando el aparato fabricado por la empresa B
y_real_b=y_b.to_numpy()
y_real_b=y_real_b.reshape(-1)
y_real_b

n=len(y_real_b)
y_real_b

#Calculamos la diferencia entre los resultados del monto reales y los estimados por medio de la regresión lineal 
residual_b=y_real_b-y_estim_b
residual_b

y_b=y_b.to_numpy().reshape(-1)
y_b
df=pd.DataFrame(y_b,
                columns=['monto'])
df['horas']=b1
df

# Calculamos el error estándar de las betas con 1000 simulaciones para la empresa B
simul=1000
beta1_boost_B=np.array([])
beta0_boost_B=np.array([])
for i in range(0,simul):
  horas_i=np.random.choice(y_b, len(b1), replace=True)
  df_aux=pd.DataFrame(horas_i, columns=['horas'])
  df_aux=pd.merge(df_aux,df,how="inner", on=['horas'])
  df_aux

  X=df_aux["horas"]
  y=df_aux["monto"]
  reg_i=linear_model.LinearRegression() 
  reg_i.fit(X,y)
  beta1_boost_B=np.append(beta1_boost_B,reg_i.coef_)
  beta0_boost_B=np.append(beta0_boost_B,reg_i.intercept_)

betas_B=pd.DataFrame(beta1_boost_B,
                columns=['beta_1'])
betas_B['beta_0']=beta0_boost_B
betas_B

# Empresa C
c1 = c[["horas"]]
y_c = c[["monto"]]

reg.fit(c1, y_c)
reg.coef_
reg.intercept_

Y_c_pred = reg.predict(c1)
y_estim_c= Y_c_pred.reshape(-1)
y_estim_c

x_c=c1.to_numpy().reshape(-1)
x_c

y_real_c=y_c.to_numpy()
y_real_c=y_real_c.reshape(-1)
y_real_c
n=len(y_real_c)
y_real_c

residual_c=y_real_c-y_estim_c
residual_c

# Calculamos el error estándar de las betas con 1000 simulaciones para la empresa C
simul=1000
beta1_boost_C=np.array([])
beta0_boost_C=np.array([])

for i in range(0,simul):
  horas_i=np.random.choice(c1, len(c1), replace=True)
  df_aux=pd.DataFrame(horas_i, columns=['horas'])
  df_aux=pd.merge(df_aux,df,how="inner", on=['horas'])
  df_aux

  X=df_aux[["horas"]]
  y=df_aux[["monto"]]

  reg_i=linear_model.LinearRegression() 
  reg_i.fit(X,y)

  beta1_boost_C=np.append(beta1_boost,reg_i.coef_)
  beta0_boost_C=np.append(beta0_boost,reg_i.intercept_)

betas_C=pd.DataFrame(beta1_boost_C,
                columns=['beta_1'])
betas_C['beta_0']=beta0_boost_C
betas_C
